"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @packageDocumentation
 *
 * This file is a script for internal usage.
 * It copies over and bundles .d.ts files from the code generated from the `typechain` library.
 *
 * The `typechain` library generates typesafe ethers.js based contract abstractions.
 */
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = require("fs");
const path_1 = require("path");
const shelljs_1 = require("shelljs");
// when this is non-empty, no files will be written
const DRY_RUN = process.env.DRY_RUN;
// logging functions with colour output
const err = (...args) => console.error(chalk_1.default.red(...args));
const warn = (...args) => console.warn(chalk_1.default.yellow(...args));
const log = (...args) => console.log(chalk_1.default.green(...args));
const info = (...args) => console.log(chalk_1.default.grey(...args));
function main() {
    const [generatedPath, distPath] = [process.argv[2], process.argv[3]].map(p => path_1.resolve(p));
    exportGeneratedContractFactories(generatedPath, distPath);
}
main();
/**
 * Export all generated contract factories and their associated types
 *
 * @param generatedPath The path of the generated files
 * @param distPath The path of the post-tsc generated files
 */
function exportGeneratedContractFactories(generatedPath, distPath) {
    const dir = getGeneratedFilePaths(generatedPath);
    const exportPaths = dir
        .map(makeExportPath)
        .filter(Boolean)
        .join('\n');
    info(`Export paths:\n${exportPaths}`);
    if (!DRY_RUN) {
        makeBarrelFile(generatedPath, exportPaths);
        copyTypings(generatedPath, distPath);
    }
}
exports.exportGeneratedContractFactories = exportGeneratedContractFactories;
/**
 * This copies the .d.ts files from the generated phase over,
 * since the typescript compiler drops any .d.ts source files during
 * compilation
 *
 * @param generatedPath The path of the generated files
 * @param distPath The path of the post-tsc generated files
 */
function copyTypings(generatedPath, distPath) {
    shelljs_1.mkdir('-p', distPath);
    shelljs_1.cp(`${generatedPath}/*.d.ts`, distPath);
}
/**
 * Create a barrel file which contains all of the exports.
 * This will replace the existing barrel file if it already exists.
 *
 * @path the path to create the barrel file
 * @param data The data to write to the barrel file
 */
function makeBarrelFile(path, data) {
    const exportFilePath = path_1.join(path, 'index.ts');
    warn(`Writing barrel file to ${exportFilePath}`);
    fs_1.writeFileSync(exportFilePath, data);
    mergeIndexes(path);
}
/**
 * Making a barrel file makes us end up with two index files,
 * since one already is generated (albeit with a .d.ts extension).
 *
 * This function merges both of them into one index file, and deletes the
 * .d.fs one.
 *
 * @param path The path of the generated files
 */
function mergeIndexes(path) {
    const exportFilePath = path_1.join(path, 'index.ts');
    const declarationsFilePath = path_1.join(path, 'index.d.ts');
    const declarationFile = shelljs_1.cat(declarationsFilePath);
    const exportsFile = shelljs_1.cat(exportFilePath);
    fs_1.writeFileSync(exportFilePath, [declarationFile, exportsFile].join('\n'));
    shelljs_1.rm(declarationsFilePath);
}
/**
 * Check if the generated directory for smart contract factories exists
 *
 * @param path The path of the generated files
 */
function generatedDirExists(path) {
    log(`Checking if directory: ${path} exists...`);
    return shelljs_1.test('-d', path);
}
/**
 * Get all the generated file paths from the generated directory
 *
 * @param path The path of the generated files
 */
function getGeneratedFilePaths(path) {
    if (!generatedDirExists(path)) {
        err(`Directory ${path} does not exist. Exiting...`);
        process.exit(1);
    }
    log(`Directory ${path} exists, continuing...`);
    return shelljs_1.ls(path);
}
/**
 * Create an es6 export of a filename, handles interface and index conflicts naively
 *
 * @param fileName The filename to export
 */
function makeExportPath(fileName) {
    const { name } = path_1.parse(fileName);
    if (name.endsWith('.d')) {
        return '';
    }
    else if (name === 'index') {
        return '';
    }
    else {
        return `export * from './${name}'`;
    }
}
//# sourceMappingURL=export-generated-contract-factories.js.map